module ELegitimation.BankID where

import Kontra
import User.UserControl
import System.Process
import System.Exit
import System.IO
import System.Directory
import Control.Concurrent
import Data.List
import Happstack.Server
import Happstack.State
import Doc.DocState
import Misc
import Session
import Control.Monad.State
import Doc.DocControl
import SOAP.SOAP
import qualified Data.ByteString as BS
import qualified Data.ByteString.UTF8 as BS hiding (length, drop, break)
import qualified Data.ByteString.Lazy.UTF8 as BSL hiding (length, drop)
import qualified Data.ByteString.Lazy as BSL
import Data.Maybe

import Text.XML.HaXml.XmlContent.Parser 
import Text.XML.HaXml.XmlContent

import KontraLink

import ELegitimation.ELeg
import MinutesTime
import Templates.Templates

{- |
   Handle the Ajax request for initiating a BankID transaction.
   URL: /s/{provider}/{docid}/{signid}/{magic}
   Method: GET
 -}
handleSignBankID :: String -> DocumentID -> SignatoryLinkID -> MagicHash -> Kontra Response
handleSignBankID provider docid signid magic = do
    ctx@Context { ctxtime = MinutesTime time seconds, ctxtemplates } <- get

    -- sanity check
    document <- queryOrFail $ GetDocumentByDocumentID docid
    checkLinkIDAndMagicHash document signid magic

    unless (document `allowsIdentification` ELegitimationIdentification) mzero

    -- request a nonce
    nonceresponse <- generateChallenge
    case nonceresponse of
        Left (ImplStatus _a _b code msg) -> 
            return $ toResponse $ toJSON [("status", JInt code), ("msg", JString msg)]
        Right (nonce, transactionid) -> do
            -- encode the text to be signed
            tbs <- liftIO $ getTBS ctxtemplates document
            providerCode <- providerStringToNumber  provider
            encodetbsresponse <- encodeTBS providerCode tbs transactionid 
            case encodetbsresponse of
                Left (ImplStatus _a _b code msg) -> 
                    return $ toResponse $ toJSON [("status", JInt code), ("msg", JString msg)]
                Right text -> do
                    -- store in session
                    addELegTransaction ELegTransaction 
                                            { transactionservertime = MinutesTime time seconds
                                            , transactiontransactionid = transactionid
                                            , transactiontbs = tbs
                                            , transactionencodedtbs = text
                                            , transactionsignatorylinkid = Just signid
                                            , transactiondocumentid = docid
                                            , transactionmagichash = Just magic
                                            , transactionnonce = nonce
                                            }
                    return $ toResponse $ toJSON [("status", JInt 0)
                                                 ,("servertime", JString $ show $ 60 * time + seconds)
                                                 ,("nonce", JString nonce)
                                                 ,("tbs", JString text)
                                                 ,("transactionid", JString transactionid)]

{- |
   Handle POST when invitee wants to sign with BankID
   URL: /s/{docid}/{sigid}/{magic}
   Method: POST
   params
     provider -- the eleg provider (bankid, nordea, telia)
     signature -- signature generated by BankID plugin
     transactionid -- the id of the transaction from the BankID Ajax request
     fieldname -- zero or more names of fields filled out by author
     fieldvalues -- zero or more (same as # of fieldnames) of values filled out by author
 -}
handleSignPostBankID :: DocumentID -> SignatoryLinkID -> MagicHash -> Kontra KontraLink
handleSignPostBankID docid signid magic = do
    ctx@Context { ctxelegtransactions, ctxtime, ctxipnumber } <- get

    -- POST values
    provider      <- getDataFnM $ look "eleg"
    signature     <- getDataFnM $ look "signature"
    transactionid <- getDataFnM $ look "transactionid"
    fieldnames    <- getAndConcat "fieldname"
    fieldvalues   <- getAndConcat "fieldvalue"

    -- request validation
    document@Doc.DocState.Document{ documentstatus = olddocumentstatus
                                  , documentsignatorylinks }
        <- queryOrFail $ GetDocumentByDocumentID docid

    checkLinkIDAndMagicHash document signid magic
    unless (document `allowsIdentification` ELegitimationIdentification) mzero
    let Just siglink@SignatoryLink 
            { signatorydetails = details } = signlinkFromDocById document signid

    -- valid transaction?
    ELegTransaction { transactionsignatorylinkid = Just tsignid
                    , transactionmagichash       = Just tmagic
                    , transactiondocumentid      = tdocid
                    , transactiontbs
                    , transactionencodedtbs
                    , transactionnonce
                    } <- findTransactionByIDOrFail ctxelegtransactions transactionid

    when (tsignid /= signid) mzero
    when (tdocid  /= docid)  mzero
    when (tmagic  /= magic)  mzero
    -- end validation

    providerCode <- providerStringToNumber provider
    -- send signature to ELeg
    done <- verifySignature providerCode
                transactionencodedtbs
                signature
                transactionnonce
                transactionid

    case done of
        -- error state
        Left (ImplStatus _a _b code msg) -> do
            liftIO $ print $ toJSON [("status", JInt code), ("msg", JString msg)]
            addFlashMsg $ toFlashMsg OperationFailed $ "E-Legitimation request failed: " ++ msg
            return $ LinkSignDoc document siglink
        -- successful request
        Right (cert, attrs) -> do
            providerType <- providerStringToType provider
            let fields = zip fieldnames fieldvalues
                signinfo = SignatureInfo { signatureinfotext = transactiontbs
                                         , signatureinfosignature = signature
                                         , signatureinfocertificate = cert
                                         , signatureinfoprovider = providerType
                                         }
            -- compare information from document (and fields) to that obtained from BankID
            let contractFirst  = signatoryfstname details
                contractLast   = signatorysndname details
                contractNumber = mergeTwo (signatorynumber details) (fieldvaluebyid (BS.fromString "signr") fields)

                elegFirst  = fieldvaluebyid (BS.fromString "First Name") attrs
                elegLast   = fieldvaluebyid (BS.fromString "Last Name")  attrs
                elegNumber = fieldvaluebyid (BS.fromString "Number")     attrs

                mfinal = mergeInfo 
                            (contractFirst, contractLast, contractNumber)
                            (elegFirst,     elegLast,     elegNumber)
            case mfinal of
                -- either number or last name do not match
                Left msg -> do
                    liftIO $ print msg
                    addFlashMsg $ toFlashMsg OperationFailed msg
                    return $ LinkSignDoc document siglink
                -- we have merged the info!
                Right (finalFirst, finalLast, finalNumber) -> do
                    newdocument <- update $ SignDocument docid 
                                                signid 
                                                ctxtime 
                                                ctxipnumber
                                                (Just signinfo) 
                                                fields 
                                                (Just finalFirst)
                                                (Just finalLast) 
                                                (Just finalNumber)
                    case newdocument of
                        -- signature failed
                        Left message -> do
                            addFlashMsg $ toFlashMsg OperationFailed message
                            return LinkMain -- where should we go?
                        Right document -> do
                            postDocumentChangeAction document olddocumentstatus (Just signid)
                            return $ LinkSigned docid signid

{- |
    Handle the ajax request for an eleg signature for the author.
    URL: /d/{provider}/{docid}
    Method: GET
-}
handleIssueBankID :: String -> DocumentID -> Kontra Response
handleIssueBankID provider docid = withUserGet $ do
    ctx@Context { ctxtime = MinutesTime time seconds, ctxmaybeuser = Just author, ctxtemplates } <- get

    document <- queryOrFail $ GetDocumentByDocumentID docid
    
    failIfNotAuthor document author

    nonceresponse <- generateChallenge
    case nonceresponse of
        Left (ImplStatus _a _b code msg) -> 
            return $ toResponse $ toJSON [("status", JInt code), ("msg", JString msg)]
        Right (nonce, transactionid) -> do
            -- encode the text to be signed
            tbs <- liftIO $ getTBS ctxtemplates document
            providerCode <- providerStringToNumber provider
            encodetbsresponse <- encodeTBS providerCode tbs transactionid 
            case encodetbsresponse of
                Left (ImplStatus _a _b code msg) -> 
                    return $ toResponse $ toJSON [("status", JInt code), ("msg", JString msg)]
                Right text -> do
                    -- store in session
                    addELegTransaction ELegTransaction 
                                        { transactionservertime = ctxtime ctx
                                        , transactiontransactionid = transactionid
                                        , transactiontbs = tbs
                                        , transactionencodedtbs = text
                                        , transactionsignatorylinkid = Nothing
                                        , transactiondocumentid = docid
                                        , transactionmagichash = Nothing
                                        , transactionnonce = nonce
                                        }
                    return $ toResponse $ toJSON [("status", JInt 0)
                                                 ,("servertime", JString $ show $ 60 * time + seconds)
                                                 ,("nonce", JString nonce)
                                                 ,("tbs", JString text)
                                                 ,("transactionid", JString transactionid)]

{- |
   Handle POST when author wants to sign+issue document
   URL: /d/{docid}
   Method: POST
   params
     provider -- the eleg provider (bankid, nordea, telia)
     signature -- signature generated by BankID plugin
     transactionid -- the id of the transaction from the BankID Ajax request
     fieldname -- zero or more names of fields filled out by author
     fieldvalues -- zero or more (same as # of fieldnames) of values filled out by author
 -}
handleIssuePostBankID :: DocumentID -> Kontra KontraLink
handleIssuePostBankID docid = withUserPost $ do
    ctx@Context { ctxmaybeuser = Just author, ctxelegtransactions } <- get

    provider      <- getDataFnM $ look "eleg"
    signature     <- getDataFnM $ look "signature"
    transactionid <- getDataFnM $ look "transactionid"
    fieldnames    <- getAndConcat "fieldname"
    fieldvalues   <- getAndConcat "fieldvalue"
    
    document <- queryOrFail $ GetDocumentByDocumentID docid
    
    failIfNotAuthor document author

    -- valid transaction?
    ELegTransaction { transactiondocumentid      = tdocid
                    , transactiontbs
                    , transactionencodedtbs
                    , transactionnonce
                    } <- findTransactionByIDOrFail ctxelegtransactions transactionid

    when (tdocid  /= docid)  mzero
    -- end validation

    providerCode <- providerStringToNumber provider
    done <- verifySignature providerCode
                transactionencodedtbs
                signature
                transactionnonce
                transactionid

    case done of
        Left (ImplStatus _a _b code msg) -> do
            liftIO $ print $ toJSON [("status", JInt code), ("msg", JString msg)]
            -- change me! I should return back to the same page
            return LinkMain
        Right (cert, attrs) -> do
            providerType <- providerStringToType provider
            let siginfo = SignatureInfo { signatureinfotext = transactiontbs
                                        , signatureinfosignature = signature
                                        , signatureinfocertificate = cert
                                        , signatureinfoprovider = providerType
                                        }
            doc2 <- updateDocument ctx author document $ Just siginfo
            return $ LinkIssueDoc docid


-- JSON - just enough to get things working

data JSONValue = JString String
               | JInt Int  

kvJson :: (String, JSONValue) -> String
kvJson (k, JInt v) = "\"" ++ k ++ "\" : " ++ show v  
kvJson (k, JString v) = "\"" ++ k ++ "\" : \"" ++ v ++ "\""

toJSON :: [(String, JSONValue)] -> String
toJSON kvs = "{ " ++ (concat $ intersperse ", " (map kvJson kvs)) ++ " }"

-- SOAP

endpoint = "https://eidt.funktionstjanster.se:18898/osif"

data ImplStatus = ImplStatus Int String Int String

data GenerateChallengeRequest = GenerateChallengeRequest Int String

instance HTypeable (GenerateChallengeRequest) where
    toHType x = Defined "GenerateChallengeRequest" [] []
instance XmlContent (GenerateChallengeRequest) where
    toContents (GenerateChallengeRequest provider policy) =
        [CElem (Elem "generateChallengeRequest" 
                [mkAttr "xmlns" "urn:www.sll.se/wsdl/soap/osif"]
                [CElem (Elem "provider"
                                 [mkAttr "xmlns" ""]
                                 (toText $ show provider)) ()
                ,CElem (Elem "policy"
                                 [mkAttr "xmlns" ""]
                                 (toText policy)) ()
                ]) 
         ()]
    parseContents = error "Please do not parse GenerateChallengeRequest"

data GenerateChallengeResponse = GenerateChallengeResponse ImplStatus String String

instance HTypeable (GenerateChallengeResponse) where
    toHType x = Defined "GenerateChallengeResponse" [] []
instance XmlContent (GenerateChallengeResponse) where
    toContents _ = error "Do not serialize GenerateChallengeResponse"
    parseContents =  do
        { e <- elementNS "generateChallengeResponse"
        ; interior e $ do
            { s <- elementNS "status"
            ; status <- interior s $ do
                          { errorGroup <- inElementNS "errorGroup" text
                          ; errorGroupDescription <- optional $ inElementNS "errorGroupDescription" text
                          ; errorCode <- inElementNS "errorCode" text
                          ; errorCodeDescription <- optional $ inElementNS "errorCodeDescription" text
                          ; return (ImplStatus (read errorGroup) 
                                               (fromMaybe "" errorGroupDescription)
                                               (read errorCode)
                                               (fromMaybe "" errorCodeDescription))
                          }

            ; challenge <- optional $ inElementNS "challenge" text
            ; transactionid <- optional $ inElementNS "transactionID" text
            ; return (GenerateChallengeResponse status
                                                (fromMaybe "" challenge)
                                                (fromMaybe "" transactionid))
            }
        } `adjustErr` ("in <GenerateChallengeResponse>, "++)

data EncodeTBSRequest = EncodeTBSRequest Int String String String

instance HTypeable (EncodeTBSRequest) where
    toHType x = Defined "EncodeTBSRequest" [] []
instance XmlContent (EncodeTBSRequest) where
    toContents (EncodeTBSRequest provider policy tbs transactionID) =
        [CElem (Elem "encodeTBSRequest" 
                [mkAttr "xmlns" "urn:www.sll.se/wsdl/soap/osif"]
                [CElem (Elem "provider"
                                 [mkAttr "xmlns" ""]
                                 (toText $ show provider)) ()
                ,CElem (Elem "policy"
                                 [mkAttr "xmlns" ""]
                                 (toText policy)) ()
                ,CElem (Elem "transactionID"
                                 [mkAttr "xmlns" ""]
                                 (toText transactionID)) ()
                ,CElem (Elem "tbsText"
                                 [mkAttr "xmlns" ""]
                                 (toText tbs)) ()
                ]) 
         ()]
    parseContents = error "Please do not parse EncodeTBSRequest"

data EncodeTBSResponse = EncodeTBSResponse ImplStatus String String

instance HTypeable (EncodeTBSResponse) where
    toHType x = Defined "EncodeTBSResponse" [] []
instance XmlContent (EncodeTBSResponse) where
    toContents _ = error "Do not serialize EncodeTBSResponse"
    parseContents =  do
        { e <- elementNS "encodeTBSResponse"
        ; interior e $ do
            { s <- elementNS "status"
            ; status <- interior s $ do
                          { errorGroup <- inElementNS "errorGroup" text
                          ; errorGroupDescription <- optional $ inElementNS "errorGroupDescription" text
                          ; errorCode <- inElementNS "errorCode" text
                          ; errorCodeDescription <- optional $ inElementNS "errorCodeDescription" text
                          ; return (ImplStatus (read errorGroup) 
                                               (maybe "" id errorGroupDescription)
                                               (read errorCode)
                                               (maybe "" id errorCodeDescription))
                          }

            ; text2 <- optional $ inElementNS "text" text
            ; transactionid <- optional $ inElementNS "transactionID" text
            ; return (EncodeTBSResponse status
                                                (maybe "" id text2)
                                                (maybe "" id transactionid))
            }
        } `adjustErr` ("in <EncodeTBSResponse>, "++)

data VerifySignatureRequest = VerifySignatureRequest Int String String String String String

instance HTypeable (VerifySignatureRequest) where
    toHType x = Defined "VerifySignatureRequest" [] []
instance XmlContent (VerifySignatureRequest) where
    toContents (VerifySignatureRequest provider policy tbs signature nonce transactionID) =
        [CElem (Elem "verifySignatureRequest" 
                [mkAttr "xmlns" "urn:www.sll.se/wsdl/soap/osif"]
                [CElem (Elem "provider"
                                 [mkAttr "xmlns" ""]
                                 (toText $ show provider)) ()
                ,CElem (Elem "policy"
                                 [mkAttr "xmlns" ""]
                                 (toText policy)) ()
                ,CElem (Elem "transactionID"
                                 [mkAttr "xmlns" ""]
                                 (toText transactionID)) ()
                ,CElem (Elem "tbsText"
                                 [mkAttr "xmlns" ""]
                                 (toText tbs)) ()
                ,CElem (Elem "signature"
                                 [mkAttr "xmlns" ""]
                                 (toText signature)) ()
                ,CElem (Elem "nonce"
                                 [mkAttr "xmlns" ""]
                                 (toText nonce)) ()
                ]) 
         ()]
    parseContents = error "Please do not parse VerifySignatureRequest"

slurpAttributes = slurpAttributes' []

slurpAttributes' ls = do
  att <- optional $ inElementNS "attributes" $ do
                        name <- inElementNS "name" text
                        value <- inElementNS "value" text
                        return (BS.fromString name, BS.fromString value)
  case att of
    Nothing -> return ls
    Just nv -> slurpAttributes' $ nv : ls
  

data VerifySignatureResponse = VerifySignatureResponse ImplStatus [(BS.ByteString, BS.ByteString)] String

instance HTypeable (VerifySignatureResponse) where
    toHType x = Defined "VerifySignatureResponse" [] []
instance XmlContent (VerifySignatureResponse) where
    toContents _ = error "Do not serialize VerifySignatureResponse"
    parseContents =  do
        { e <- elementNS "verifySignatureResponse"
        ; interior e $ do
            { s <- elementNS "status"
            ; status <- interior s $ do
                          { errorGroup <- inElementNS "errorGroup" text
                          ; errorGroupDescription <- optional $ inElementNS "errorGroupDescription" text
                          ; errorCode <- inElementNS "errorCode" text
                          ; errorCodeDescription <- optional $ inElementNS "errorCodeDescription" text
                          ; return (ImplStatus (read errorGroup) 
                                               (maybe "" id errorGroupDescription)
                                               (read errorCode)
                                               (maybe "" id errorCodeDescription))
                          }
            ; attributes <- slurpAttributes
            ; transactionid <- optional $ inElementNS "transactionID" text
            ; certificate <- optional $ inElementNS "certificate" text
            ; return (VerifySignatureResponse status attributes (maybe "" id certificate))
            }
        } `adjustErr` ("in <VerifySignatureResponse>, "++)


generateChallenge :: Kontra (Either ImplStatus (String, String))
generateChallenge = do
  eresponse <- liftIO $ makeSoapCallINSECURE endpoint "GenerateChallenge" $ GenerateChallengeRequest 6 "logtest004"
  case eresponse of
    Left msg -> do
      liftIO $ print msg
      error msg
    Right (GenerateChallengeResponse (ImplStatus a b status msg) challenge transactionid) -> do
                      if status == 0
                         then return $ Right (challenge, transactionid)
                         else return $ Left (ImplStatus a b status msg)
                 
encodeTBS :: Int -> String -> String -> Kontra (Either ImplStatus String)
encodeTBS provider tbs transactionID = do
  eresponse <- liftIO $ makeSoapCallINSECURE endpoint "EncodeTBS" $ EncodeTBSRequest provider "logtest004" tbs transactionID
  case eresponse of
    Left msg -> do
      liftIO $ print msg
      error msg
    Right (EncodeTBSResponse (ImplStatus a b status msg) text c) -> do
                      if status == 0
                         then return $ Right text
                         else return $ Left (ImplStatus a b status msg)

verifySignature :: Int -> String -> String -> String -> String -> Kontra (Either ImplStatus (String, [(BS.ByteString, BS.ByteString)]))
verifySignature provider tbs signature nonce transactionID = do
  eresponse <- liftIO $ makeSoapCallINSECURE endpoint "VerifySignature" $ VerifySignatureRequest provider "logtest004" tbs signature nonce transactionID
  case eresponse of
    Left msg -> do
      liftIO $ print msg
      error msg
    Right (VerifySignatureResponse (ImplStatus a b status msg) attrs certificate) -> do
                      if status == 0
                         then return $ Right (certificate, attrs)
                         else return $ Left (ImplStatus a b status msg)

{- | Merge two bits of information, choosing b over a.
 -}                             
mergeTwo :: BS.ByteString -> BS.ByteString -> BS.ByteString
mergeTwo a b 
    | b == BS.fromString "" = a
    | a == BS.fromString "" = b
    | a == b  = b
    | a /= b  = b
 
{- | Compare signatory information from contract with that from the
     E-Legitimation provider. Returns Either and error message or the
     correct value.
 -}
mergeInfo :: (BS.ByteString, BS.ByteString, BS.ByteString) -> (BS.ByteString, BS.ByteString, BS.ByteString) -> Either String (BS.ByteString, BS.ByteString, BS.ByteString)
mergeInfo (contractFirst, contractLast, contractNumber) (elegFirst, elegLast, elegNumber)
    | (not $ BS.null contractLast) &&
      (not $ BS.null elegLast    ) &&
      contractLast   /= elegLast   = Left "The last name from your E-Legitimation provider does not match your last name entered on the contract. Please notify the author."
    | (not $ BS.null contractNumber) &&
      (not $ BS.null elegNumber    ) &&
      contractNumber /= elegNumber = Left "Numbers do not match."
    | otherwise                    = Right (mergeTwo contractFirst  elegFirst,
                                            mergeTwo contractLast   elegLast,
                                            mergeTwo contractNumber elegNumber)

allowsIdentification document idtype = 
    isJust $ find (== idtype) $ documentallowedidtypes document

findTransactionByIDOrFail :: [ELegTransaction] -> String -> Kontra ELegTransaction
findTransactionByIDOrFail transactions transactionsid = 
    case find ((== transactionsid) . transactiontransactionid) transactions of
      Nothing                                                         -> mzero
      Just (ELegTransaction { transactionsignatorylinkid = Nothing }) -> mzero
      Just (ELegTransaction { transactionmagichash       = Nothing }) -> mzero
      Just trans                                                      -> return trans
               
getTBS templates doc =
    renderTemplate templates "tbs" $ do
        field "documentname"   $ documenttitle doc
        field "documentnumber" $ documentid doc
        field "tbssigentries"  $ getSigEntries templates doc
        
getSigEntries templates doc = 
    mapM ((getSigEntry templates) . signatorydetails) $ documentsignatorylinks doc

getSigEntry templates signatorydetails =
    renderTemplate templates "tbssig" $ do
        field "firstname" $ signatoryfstname signatorydetails
        field "lastname"  $ signatorysndname signatorydetails
        field "company"   $ signatorycompany signatorydetails
        field "number"    $ signatorynumber  signatorydetails

fieldvaluebyid _ [] = BS.fromString ""
fieldvaluebyid id ((k, v):xs)
    | k == id   = v
    | otherwise = fieldvaluebyid id xs

providerStringToNumber :: String -> Kontra Int
providerStringToNumber provider 
    | provider == "bankid" = return 6
    | provider == "nordea" = return 4
    | provider == "telia"  = return 5
    | otherwise            = mzero

providerStringToType :: String -> Kontra SignatureProvider
providerStringToType provider
    | provider == "bankid" = return BankIDProvider
    | provider == "nordea" = return NordeaProvider
    | provider == "telia"  = return TeliaProvider
    | otherwise            = mzero
